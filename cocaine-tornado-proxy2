#!/usr/bin/env python

import random
import logging
import atexit
import pwd
import time
import re
import os
import sys
from functools import partial
from signal import SIGTERM
from collections import defaultdict

import tornado.httpserver
import tornado.options
from tornado import ioloop

import msgpack

from cocaine.services import Service

logger = logging.getLogger()


class Daemon(object):

    def __init__(self, pidfile, userid=None, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
        self.stdin = stdin
        self.stdout = stdout
        self.stderr = stderr
        self.pidfile = pidfile
        self.userid = userid

    def daemonize(self):
        """Double-fork magic"""
        if self.userid:
            uid = pwd.getpwnam(self.userid).pw_uid
            os.seteuid(uid)
        try:
            pid = os.fork()
            if pid > 0:
                sys.exit(0)
        except OSError, err:
            sys.stderr.write("First fork failed: %d (%s)\n" % (err.errno, err.strerror))
            sys.exit(1)
        # decouple from parent environment
        os.chdir("/")
        os.setsid()
        os.umask(0)

        # Second fork
        
        try:
            pid = os.fork()
            if pid > 0:
                sys.exit(0)
        except OSError, err:
            sys.stderr.write("Second fork failed: %d (%s)\n" % (err.errno, err.strerror))
            sys.exit(1)
            
        sys.stdout.flush()
        sys.stderr.flush()
        si = file(self.stdin, 'r')
        so = file(self.stdout, 'w')
        se = file(self.stderr, 'w')
        os.dup2(si.fileno(), sys.stdin.fileno())
        os.dup2(so.fileno(), sys.stdout.fileno())
        os.dup2(se.fileno(), sys.stderr.fileno())

        #write PID file
        atexit.register(self.delpid)
        pid = str(os.getpid())
        file(self.pidfile,'w').write("%s\n" % pid)

    def delpid(self):
        try:
            os.remove(self.pidfile)
        except Exception, err:
            pass

    def start(self, *args):
        """
        Start  the daemon
        """

        try:
            pf = file(self.pidfile, 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None

        if pid:
            msg = "pidfile %s exists. Exit.\n"
            sys.stderr.write(msg % self.pidfile)
            sys.exit(1)

        self.daemonize()
        self.run(*args)

    def stop(self):
        """
        Stop daemon.
        """
        try:
            pf = file(self.pidfile, 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None

        if not pid:
            msg = "pidfile %s doesn't exist. Exit.\n"
            sys.stderr.write(msg % self.pidfile)
            sys.exit(1)

        #Kill
        try:
            while True:
                os.kill(pid, SIGTERM)
                time.sleep(0.5)
        except OSError, err:
            err = str(err)
            if err.find("No such process") > 0:
                if os.path.exists(self.pidfile):
                    os.remove(self.pidfile)
                sys.stdout.write("Process %d stoped succefully\n" % pid)
            else:
                print str(err)
                sys.exit(1)

    def status(self):
        try:
            with file(self.pidfile, 'r') as pf:
                pid = int(pf.read().strip())
        except IOError:
            pid = None

        if not pid:
            msg = "Stopped\n"
            sys.stderr.write(msg)
            sys.exit(1)

        try:
            os.kill(pid, 0)
        except OSError as err:
            msg = "Stopped\n"
            sys.stderr.write(msg)
            sys.exit(1)

        sys.stdout.write("Running. PID %d\n" % pid)
        sys.exit(0)

    def restart(self, *args):
        self.stop()
        self.start(*args)

    def run(self, *args):
        pass


SERVICE_CACHE_COUNT = 5
REFRESH_PERIOD = 10
DEFAULT_USER = "cocaine"

tornado.options.define("port", default=8088, type=int, help="listening port number")
tornado.options.define("count", default=SERVICE_CACHE_COUNT, type=int, help="count of instances per service")
tornado.options.define("daemon", default=False, type=bool, help="daemonize")
tornado.options.define("pidfile", default="/var/run/tornado", type=str, help="pidfile")
tornado.options.define("user", default=DEFAULT_USER, type=str, help="Set process's username")
actions = tornado.options.parse_command_line()


cache = defaultdict(list)
dying = defaultdict(list)
URL_REGEX = re.compile(r"/([^/]*)/([^/]*)")
io_loop = ioloop.IOLoop.instance()


DEFAULT_TIMEOUT=1
def get_timeout(app_name):
    """dummy"""
    return DEFAULT_TIMEOUT


def reconnector(app, name):
    try:
        logger.info("Try reconnect %s %s" % (app.servicename, "%s:%s" % app.service_endpoint))
        app.reconnect()
    except Exception as err:
        logger.error("Unable to reconnect %s, because %s" % (name, str(err)))
    dying[name].remove(app)
    cache[name].append(app)
    next_refr = random.random() * REFRESH_PERIOD + get_timeout(name)*10
    io_loop.add_timeout(time.time() + next_refr, move_to_dying(app, name))
    if app.connected:
        logger.info("Reconnect %s %s succesfully. Next refresh after %f"\
                         % (app.servicename, "%s:%s" % app.service_endpoint, next_refr))
    else:
        logger.warning("Unable to reconnect %s" % name)


def move_to_dying(app, name):
    def wrapper():
        active_apps = len(cache[name])
        if active_apps < tornado.options.options.count/2:
            return
        logger.info("Move to dying %s %s from pool with active %d" % (app.servicename, "%s:%s" % app.service_endpoint, active_apps))
        # Move service to sandbox for waiting current sessions
        try:
            inx = cache[name].index(app)
            # To avoid gc collect
            dying[name].append(cache[name].pop(inx))
        except ValueError as err:
            logger.error("Broken cache")
            return

        io_loop.add_timeout(time.time() + get_timeout(name), partial(reconnector, app, name))
    return wrapper


def get_service(name):
    if len(cache[name]) < SERVICE_CACHE_COUNT - len(dying[name]):
        try:
            created = [Service(name, raise_reconnect_failure=False)
                                for _ in xrange(0, 10 - len(cache[name]))]
            [logger.info("Connect to app: %s endpoint %s " % (app.servicename, "%s:%s" % app.service_endpoint))
                                    for app in created]
            cache[name].extend(created)
            for app in created:
                io_loop.add_timeout(time.time() + random.random() * REFRESH_PERIOD, move_to_dying(app, name))
        except Exception as err:
            logger.error(str(err))
            return None
    chosen = random.choice(cache[name])
    if chosen.connected:
        return chosen
    else:
        logger.warning("Service %s disconnected %s" % (chosen.servicename,
                                                        chosen.service_endpoint))
        try:
            chosen.reconnect()
            if chosen.connected:
                return chosen
            else:
                return None
        except Exception as err:
            return None


def gen(obj):
    headers = yield
    chunk = headers.get()
    body = yield
    message = body.get()
    res = "%(VERSION)s %(CODE)s %(STATUS)s\r\n%(HEADERS)s\r\n%(BODY)s" 
    headers_from_app = '\r\n'.join(': '.join(_) for _ in chunk['headers'])
    if headers_from_app:
        headers = headers_from_app + '\r\nContent-Length: %d\r\n' % len(message)
    else:
        headers = 'Content-Length: %d\r\n' % len(message)
    obj.write(res % {"VERSION" : obj.version,
                     "CODE" : chunk["code"],
                     "STATUS" : "ok",
                     "HEADERS"  : headers,
                     "BODY" : message })
    obj.finish()


def pack_httprequest(request):
    d = dict()
    d['meta'] = { "cookies" : dict((item.key, item.value) for item in request.cookies.itervalues()),
                  "headers" : dict(request.headers),
                  "host" : request.host,
                  "method" : request.method,
                  "path_info" : request.path,
                  "query_string" : request.query,
                  "remote_addr" : request.remote_ip,
                  "url" : request.uri,
                  "files" : request.files
                }
    d['body'] = request.body
    d['request'] = dict((param, value[0]) for param, value in request.arguments.iteritems())
    return d


def handle_request(request):
    match = URL_REGEX.match(request.path)
    if match is None:
        message = "Invelid url"
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                 request.version, len(message), message))
        request.finish()
        return

    name, event = match.groups()
    if name == '' or event == '':
        message = "Invelid request"
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                request.version, len(message), message))
        request.finish()
        return

    s = get_service(name)
    if s is None:
        message = "Current application %s is unavailable" % name
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                request.version, len(message), message))
        request.finish()
        return
        
    data = pack_httprequest(request)
    fut = s.invoke(event, msgpack.packb(data))
    g = gen(request)
    g.next()
    fut.then(g.send).run()


def main():
    http_server = tornado.httpserver.HTTPServer(handle_request, no_keep_alive=False)
    http_server.listen(tornado.options.options.port)
    tornado.ioloop.IOLoop.instance().start()


if __name__ == "__main__":
    if tornado.options.options.daemon:
        d = Daemon(tornado.options.options.pidfile,
                    tornado.options.options.user)
        if "start" in actions:
            d.run = main
            d.start()
        elif "stop" in actions:
            d.stop()
        elif "restart" in actions:
            d.run = main
            d.restart()
        elif "status" in actions:
            d.status()
        else:
            print("start|stop|restart|status")
            sys.exit(0)
    else:
        main()
