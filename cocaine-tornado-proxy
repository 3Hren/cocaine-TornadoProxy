#!/usr/bin/env python

import random
import logging
import time
import re
import os
import sys
import httplib
from functools import partial
from collections import defaultdict

import tornado.httpserver
import tornado.options
from tornado import ioloop

import msgpack

from cocaine.services import Service
from cocaine.exceptions import ServiceError
from cocaine.exceptions import CocaineError

from cocaineproxy import Daemon
from cocaineproxy import load_config

logger = logging.getLogger()
io_loop = ioloop.IOLoop.instance()
URL_REGEX = re.compile(r"/([^/]*)/([^/?]*)(.*)")

SERVICE_CACHE_COUNT = 5
REFRESH_PERIOD = 100
DEFAULT_TIMEOUT = 1
DEFAULT_USER = "cocaine"
DEFAULT_CONFIG_PATH = '/etc/cocaine/cocaine-tornado-proxy.conf'

tornado.options.define("port", default=8080, type=int, help="listening port number")
tornado.options.define("daemon", default=False, type=bool, help="daemonize")
tornado.options.define("pidfile", default="/var/run/tornado", type=str, help="pidfile")
tornado.options.define("user", default=DEFAULT_USER, type=str, help="Set process's username")
tornado.options.define("count", default=SERVICE_CACHE_COUNT, type=int, help="count of instances per service")
tornado.options.define("config", default=DEFAULT_CONFIG_PATH, type=str, help="path to configuration file")
actions = tornado.options.parse_command_line()

config = load_config(tornado.options.options.config)

SERVICE_CACHE_COUNT = config.get("instances") or tornado.options.options.count
REFRESH_PERIOD = config.get("refresh_timeout") or REFRESH_PERIOD
TIMEOUTS = config.get("timeouts", {})

cache = defaultdict(list) # active applications
dying = defaultdict(list) # application, whish wait for reconnection


def get_timeout(cfg, default, app_name):
    return cfg.get(app_name, default)
get_timeout = partial(get_timeout, TIMEOUTS, DEFAULT_TIMEOUT)


def reconnector(app, name):
    try:
        logger.info("Try to reconnect %s %s" % (app.servicename, "%s:%s" % app.service_endpoint))
        app.reconnect()
    except Exception as err:
        logger.error("Unable to reconnect %s, because %s" % (name, str(err)))
    dying[name].remove(app)
    cache[name].append(app)
    next_refr = (1 + random.random()) * REFRESH_PERIOD
    io_loop.add_timeout(time.time() + next_refr, move_to_dying(app, name))
    if app.connected:
        logger.info("Reconnect %s %s successfully. Next refresh after %f"\
                         % (app.servicename, "%s:%s" % app.service_endpoint, next_refr))
    else:
        logger.warning("Unable to reconnect %s" % name)


def move_to_dying(app, name):
    def wrapper():
        active_apps = len(cache[name])
        if active_apps < SERVICE_CACHE_COUNT/2:
            return
        logger.info("Move to dying %s %s from pool with active %d" % (app.servicename, "%s:%s" % app.service_endpoint, active_apps))
        # Move service to sandbox for waiting current sessions
        try:
            inx = cache[name].index(app)
            # To avoid gc collect
            dying[name].append(cache[name].pop(inx))
        except ValueError as err:
            logger.error("Broken cache")
            return

        io_loop.add_timeout(time.time() + get_timeout(name), partial(reconnector, app, name))
    return wrapper


def get_service(name):
    if len(cache[name]) < SERVICE_CACHE_COUNT - len(dying[name]):
        try:
            created = [Service(name)
                                for _ in xrange(0, 10 - len(cache[name]))]
            [logger.info("Connect to app: %s endpoint %s " % (app.servicename, "%s:%s" % app.service_endpoint))
                                    for app in created]
            cache[name].extend(created)
            for app in created:
                io_loop.add_timeout(time.time() + (1 + random.random()) * REFRESH_PERIOD, move_to_dying(app, name))
        except Exception as err:
            logger.error(str(err))
            return None
    chosen = random.choice(cache[name])
    if chosen.connected:
        return chosen
    else:
        logger.warning("Service %s disconnected %s" % (chosen.servicename,
                                                        chosen.service_endpoint))
        try:
            chosen.reconnect()
            if chosen.connected:
                logger.info("Service %s reconnect successfully" % chosen.servicename)
                return chosen
            else:
                return None
        except Exception as err:
            return None


TEMPLATE = "%(VERSION)s %(CODE)d %(STATUS)s\r\n%(HEADERS)s\r\n%(BODY)s" 
def gen(obj):
    try:
        headers = yield
        chunk = headers.get()
        body = yield
        message = body.get()
    except ServiceError as err:
        message = "Eventhandler is unavailable for this event"
        response_data = TEMPLATE % { "VERSION" : obj.version,
                         "CODE" : 501,
                         "STATUS" : httplib.responses[501],
                         "HEADERS" : 'Content-Length: %d\r\n' % len(message),
                         "BODY" : message }
    except Exception as err:
        logger.error(str(err))
    else:
        headers_from_app = '\r\n'.join(': '.join(_) for _ in chunk['headers'])
        if headers_from_app:
            headers = headers_from_app + '\r\nContent-Length: %d\r\n' % len(message)
        else:
            headers = 'Content-Length: %d\r\n' % len(message)
        response_data = TEMPLATE % {"VERSION" : obj.version,
                     "CODE" : chunk["code"],
                     "STATUS" : httplib.responses[chunk["code"]],
                     "HEADERS"  : headers,
                     "BODY" : message }
    if obj._finish_time is None:
        obj.write(response_data)
        obj.finish()


def pack_httprequest(request):
    d = dict()
    d['meta'] = { "cookies" : dict((item.key, item.value) for item in request.cookies.itervalues()),
                  "headers" : dict(request.headers),
                  "host" : request.host,
                  "method" : request.method,
                  "path_info" : request.path,
                  "query_string" : request.query,
                  "remote_addr" : request.remote_ip,
                  "url" : request.uri,
                  "files" : request.files
                }
    d['body'] = request.body
    d['request'] = dict((param, value[0]) for param, value in request.arguments.iteritems())
    return d

def on_deadline_response(response, req_uri):
    if response._finish_time is None:
        logger.error("Deadline has reached for %s" % req_uri)
        message = "Maximum time to wait for a response has reached"
        response.write("%s 504 Gateway Timeout\r\nContent-Length: %d\r\n\r\n%s" % (
                 response.version, len(message), message))
        response.finish()

def handle_request(request):
    match = URL_REGEX.match(request.uri)

    if match is None:
        message = "Invalid url"
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                 request.version, len(message), message))
        request.finish()
        return

    name, event, other = match.groups()
    if name == '' or event == '':
        message = "Invalid request"
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                request.version, len(message), message))
        request.finish()
        return
    on_deadline = partial(on_deadline_response, request, request.uri)
    # Drop from query appname and event's name
    if not other.startswith('/'):
        other = "/%s" % other
    request.uri = other
    request.path = other.partition("?")[0]

    #s = get_service(name)
    try:
        s = Service(name) 
    except Exception as err:
        log.error("Create service error %s" % str(err))
        s = None
    if s is None:
        message = "Current application %s is unavailable" % name
        request.write("%s 404 Not found\r\nContent-Length: %d\r\n\r\n%s" % (
                request.version, len(message), message))
        request.finish()
        return
        
    data = pack_httprequest(request)
    fut = s.enqueue(event, msgpack.packb(data))
    io_loop.add_timeout(time.time() + get_timeout(name), on_deadline)
    g = gen(request)
    g.next()
    fut.then(g.send).run()


def main():
    http_server = tornado.httpserver.HTTPServer(handle_request, no_keep_alive=False)
    http_server.listen(tornado.options.options.port)
    tornado.ioloop.IOLoop.instance().start()


if __name__ == "__main__":
    if tornado.options.options.daemon:
        d = Daemon(tornado.options.options.pidfile,
                    tornado.options.options.user)
        if "start" in actions:
            d.run = main
            d.start()
        elif "stop" in actions:
            d.stop()
        elif "restart" in actions:
            d.run = main
            d.restart()
        elif "status" in actions:
            d.status()
        else:
            print("start|stop|restart|status")
            sys.exit(0)
    else:
        main()
